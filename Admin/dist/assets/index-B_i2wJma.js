import{cm as wt,r as v,dI as Kt}from"./index-DJm73Gd8.js";const P=()=>{},C=P(),ut=Object,a=t=>t===C,y=t=>typeof t=="function",U=(t,e)=>({...t,...e}),Gt=t=>y(t.then),st=new WeakMap;let Yt=0;const Q=t=>{const e=typeof t,n=t&&t.constructor,i=n==Date;let s,r;if(ut(t)===t&&!i&&n!=RegExp){if(s=st.get(t),s)return s;if(s=++Yt+"~",st.set(t,s),n==Array){for(s="@",r=0;r<t.length;r++)s+=Q(t[r])+",";st.set(t,s)}if(n==ut){s="#";const c=ut.keys(t).sort();for(;!a(r=c.pop());)a(t[r])||(s+=r+":"+Q(t[r])+",");st.set(t,s)}}else s=i?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s},x=new WeakMap,lt={},ot={},gt="undefined",rt=typeof window!=gt,Rt=typeof document!=gt,Xt=()=>rt&&typeof window.requestAnimationFrame!=gt,xt=(t,e)=>{const n=x.get(t);return[()=>!a(e)&&t.get(e)||lt,i=>{if(!a(e)){const s=t.get(e);e in ot||(ot[e]=s),n[5](e,U(s,i),s||lt)}},n[6],()=>!a(e)&&e in ot?ot[e]:!a(e)&&t.get(e)||lt]};let ht=!0;const Qt=()=>ht,[Tt,_t]=rt&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[P,P],Zt=()=>{const t=Rt&&document.visibilityState;return a(t)||t!=="hidden"},te=t=>(Rt&&document.addEventListener("visibilitychange",t),Tt("focus",t),()=>{Rt&&document.removeEventListener("visibilitychange",t),_t("focus",t)}),ee=t=>{const e=()=>{ht=!0,t()},n=()=>{ht=!1};return Tt("online",e),Tt("offline",n),()=>{_t("online",e),_t("offline",n)}},ne={isOnline:Qt,isVisible:Zt},se={initFocus:te,initReconnect:ee},Nt=!wt.useId,Z=!rt||"Deno"in window,oe=t=>Xt()?window.requestAnimationFrame(t):setTimeout(t,1),ft=Z?v.useEffect:v.useLayoutEffect,dt=typeof navigator<"u"&&navigator.connection,yt=!Z&&dt&&(["slow-2g","2g"].includes(dt.effectiveType)||dt.saveData),pt=t=>{if(y(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?Q(t):"",[t,e]};let re=0;const mt=()=>++re,Mt=0,Pt=1,Ut=2,ie=3;var X={__proto__:null,ERROR_REVALIDATE_EVENT:ie,FOCUS_EVENT:Mt,MUTATE_EVENT:Ut,RECONNECT_EVENT:Pt};async function qt(...t){const[e,n,i,s]=t,r=U({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let c=r.populateCache;const R=r.rollbackOnError;let d=r.optimisticData;const A=O=>typeof R=="function"?R(O):R!==!1,w=r.throwOnError;if(y(n)){const O=n,h=[],I=e.keys();for(const _ of I)!/^\$(inf|sub)\$/.test(_)&&O(e.get(_)._k)&&h.push(_);return Promise.all(h.map(T))}return T(n);async function T(O){const[h]=pt(O);if(!h)return;const[I,_]=xt(e,h),[it,o,tt,G]=x.get(e),M=()=>{const V=it[h];return(y(r.revalidate)?r.revalidate(I().data,O):r.revalidate!==!1)&&(delete tt[h],delete G[h],V&&V[0])?V[0](Ut).then(()=>I().data):I().data};if(t.length<3)return M();let g=i,D;const H=mt();o[h]=[H,0];const E=!a(d),$=I(),L=$.data,j=$._c,q=a(j)?L:j;if(E&&(d=y(d)?d(q,L):d,_({data:d,_c:q})),y(g))try{g=g(q)}catch(V){D=V}if(g&&Gt(g))if(g=await g.catch(V=>{D=V}),H!==o[h][0]){if(D)throw D;return g}else D&&E&&A(D)&&(c=!0,_({data:q,_c:C}));if(c&&!D)if(y(c)){const V=c(g,q);_({data:V,error:C,_c:C})}else _({data:g,error:C,_c:C});if(o[h][1]=mt(),Promise.resolve(M()).then(()=>{_({_c:C})}),D){if(w)throw D;return}return g}}const Ft=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},ae=(t,e)=>{if(!x.has(t)){const n=U(se,e),i={},s=qt.bind(C,t);let r=P;const c={},R=(w,T)=>{const O=c[w]||[];return c[w]=O,O.push(T),()=>O.splice(O.indexOf(T),1)},d=(w,T,O)=>{t.set(w,T);const h=c[w];if(h)for(const I of h)I(T,O)},A=()=>{if(!x.has(t)&&(x.set(t,[i,{},{},{},s,d,R]),!Z)){const w=n.initFocus(setTimeout.bind(C,Ft.bind(C,i,Mt))),T=n.initReconnect(setTimeout.bind(C,Ft.bind(C,i,Pt)));r=()=>{w&&w(),T&&T(),x.delete(t)}}};return A(),[t,s,A,r]}return[t,x.get(t)[4]]},ce=(t,e,n,i,s)=>{const r=n.errorRetryCount,c=s.retryCount,R=~~((Math.random()+.5)*(1<<(c<8?c:8)))*n.errorRetryInterval;!a(r)&&c>r||setTimeout(i,R,s)},ue=(t,e)=>Q(t)==Q(e),[Ht,le]=ae(new Map),fe=U({onLoadingSlow:P,onSuccess:P,onError:P,onErrorRetry:ce,onDiscarded:P,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:yt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:yt?5e3:3e3,compare:ue,isPaused:()=>!1,cache:Ht,mutate:le,fallback:{}},ne),de=(t,e)=>{const n=U(t,e);if(e){const{use:i,fallback:s}=t,{use:r,fallback:c}=e;i&&r&&(n.use=i.concat(r)),s&&c&&(n.fallback=U(s,c))}return n},Ee=v.createContext({}),Re="$inf$",$t=rt&&window.__SWR_DEVTOOLS_USE__,he=$t?window.__SWR_DEVTOOLS_USE__:[],Te=()=>{$t&&(window.__SWR_DEVTOOLS_REACT__=wt)},_e=t=>y(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],me=()=>U(fe,v.useContext(Ee)),we=t=>(e,n,i)=>t(e,n&&((...r)=>{const[c]=pt(e),[,,,R]=x.get(Ht);if(c.startsWith(Re))return n(...r);const d=R[c];return a(d)?n(...r):(delete R[c],d)}),i),ge=he.concat(we),pe=t=>function(...n){const i=me(),[s,r,c]=_e(n),R=de(i,c);let d=t;const{use:A}=R,w=(A||[]).concat(ge);for(let T=w.length;T--;)d=w[T](d);return d(s,r||R.fetcher||null,R)},ve=(t,e,n)=>{const i=e[t]||(e[t]=[]);return i.push(n),()=>{const s=i.indexOf(n);s>=0&&(i[s]=i[i.length-1],i.pop())}};Te();const Wt=wt.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)}),Et={dedupe:!0},Oe=(t,e,n)=>{const{cache:i,compare:s,suspense:r,fallbackData:c,revalidateOnMount:R,revalidateIfStale:d,refreshInterval:A,refreshWhenHidden:w,refreshWhenOffline:T,keepPreviousData:O}=n,[h,I,_,it]=x.get(i),[o,tt]=pt(t),G=v.useRef(!1),M=v.useRef(!1),g=v.useRef(o),D=v.useRef(e),H=v.useRef(n),E=()=>H.current,$=()=>E().isVisible()&&E().isOnline(),[L,j,q,V]=xt(i,o),k=v.useRef({}).current,jt=a(c)?n.fallback[o]:c,vt=(u,l)=>{for(const p in k){const f=p;if(f==="data"){if(!s(u[f],l[f])&&(!a(u[f])||!s(nt,l[f])))return!1}else if(l[f]!==u[f])return!1}return!0},Ot=v.useMemo(()=>{const u=!o||!e?!1:a(R)?E().isPaused()||r?!1:a(d)?!0:d:R,l=S=>{const F=U(S);return delete F._k,u?{isValidating:!0,isLoading:!0,...F}:F},p=L(),f=V(),N=l(p),K=p===f?N:l(f);let m=N;return[()=>{const S=l(L());return vt(S,m)?(m.data=S.data,m.isLoading=S.isLoading,m.isValidating=S.isValidating,m.error=S.error,m):(m=S,S)},()=>K]},[i,o]),z=Kt.useSyncExternalStore(v.useCallback(u=>q(o,(l,p)=>{vt(p,l)||u()}),[i,o]),Ot[0],Ot[1]),St=!G.current,kt=h[o]&&h[o].length>0,B=z.data,J=a(B)?jt:B,et=z.error,Ct=v.useRef(J),nt=O?a(B)?Ct.current:B:J,Dt=kt&&!a(et)?!1:St&&!a(R)?R:E().isPaused()?!1:r?a(J)?!1:d:a(J)||d,bt=!!(o&&e&&St&&Dt),zt=a(z.isValidating)?bt:z.isValidating,Bt=a(z.isLoading)?bt:z.isLoading,Y=v.useCallback(async u=>{const l=D.current;if(!o||!l||M.current||E().isPaused())return!1;let p,f,N=!0;const K=u||{},m=!_[o]||!K.dedupe,S=()=>Nt?!M.current&&o===g.current&&G.current:o===g.current,F={isValidating:!1,isLoading:!1},Vt=()=>{j(F)},It=()=>{const b=_[o];b&&b[1]===f&&delete _[o]},Lt={isValidating:!0};a(L().data)&&(Lt.isLoading=!0);try{if(m&&(j(Lt),n.loadingTimeout&&a(L().data)&&setTimeout(()=>{N&&S()&&E().onLoadingSlow(o,n)},n.loadingTimeout),_[o]=[l(tt),mt()]),[p,f]=_[o],p=await p,m&&setTimeout(It,n.dedupingInterval),!_[o]||_[o][1]!==f)return m&&S()&&E().onDiscarded(o),!1;F.error=C;const b=I[o];if(!a(b)&&(f<=b[0]||f<=b[1]||b[1]===0))return Vt(),m&&S()&&E().onDiscarded(o),!1;const W=L().data;F.data=s(W,p)?W:p,m&&S()&&E().onSuccess(p,o,n)}catch(b){It();const W=E(),{shouldRetryOnError:at}=W;W.isPaused()||(F.error=b,m&&S()&&(W.onError(b,o,W),(at===!0||y(at)&&at(b))&&(!E().revalidateOnFocus||!E().revalidateOnReconnect||$())&&W.onErrorRetry(b,o,W,Jt=>{const ct=h[o];ct&&ct[0]&&ct[0](X.ERROR_REVALIDATE_EVENT,Jt)},{retryCount:(K.retryCount||0)+1,dedupe:!0})))}return N=!1,Vt(),!0},[o,i]),At=v.useCallback((...u)=>qt(i,g.current,...u),[]);if(ft(()=>{D.current=e,H.current=n,a(B)||(Ct.current=B)}),ft(()=>{if(!o)return;const u=Y.bind(C,Et);let l=0;const f=ve(o,h,(N,K={})=>{if(N==X.FOCUS_EVENT){const m=Date.now();E().revalidateOnFocus&&m>l&&$()&&(l=m+E().focusThrottleInterval,u())}else if(N==X.RECONNECT_EVENT)E().revalidateOnReconnect&&$()&&u();else{if(N==X.MUTATE_EVENT)return Y();if(N==X.ERROR_REVALIDATE_EVENT)return Y(K)}});return M.current=!1,g.current=o,G.current=!0,j({_k:tt}),Dt&&(a(J)||Z?u():oe(u)),()=>{M.current=!0,f()}},[o]),ft(()=>{let u;function l(){const f=y(A)?A(L().data):A;f&&u!==-1&&(u=setTimeout(p,f))}function p(){!L().error&&(w||E().isVisible())&&(T||E().isOnline())?Y(Et).then(l):l()}return l(),()=>{u&&(clearTimeout(u),u=-1)}},[A,w,T,o]),v.useDebugValue(nt),r&&a(J)&&o){if(!Nt&&Z)throw new Error("Fallback data is required when using suspense in SSR.");D.current=e,H.current=n,M.current=!1;const u=it[o];if(!a(u)){const l=At(u);Wt(l)}if(a(et)){const l=Y(Et);a(nt)||(l.status="fulfilled",l.value=!0),Wt(l)}else throw et}return{mutate:At,get data(){return k.data=!0,nt},get error(){return k.error=!0,et},get isValidating(){return k.isValidating=!0,zt},get isLoading(){return k.isLoading=!0,Bt}}},Ce=pe(Oe);export{le as m,Ce as u};
